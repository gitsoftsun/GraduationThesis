<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威中文论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_9.htm">尾页</a>
页码：4/9页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">148</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中R ?</span><span class='green'>即为评分矩阵R的最终补全矩阵，R ?</span><span class='green'>(u，i)即为用户对物品的预测评分。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">149</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本章小结</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">150</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本章主要是计算特定用户给明确的物品打分， 通俗的说就是预测用户给某一物品的评分。</span><span class='green'>用户和物品之间没有直接的关系， 但是用户有过评分记录， 同时用户的好友也有评分记录，那么计算用户与物品（用户没有评分）之间的评分。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">151</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Top-N推荐用户兴趣预测的模型</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">152</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Top-N推荐简介</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">153</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>为一个用户产生一个推荐列表大体需要两步，第一步是得到一个和用户相关的物品列表，在真正的生产中系统中包含很多件物品，</span><span class='green'>但是真正和用户相关的物品很少，我们仅仅只要基于与用户相关的物品即可；</span><a href='../sentence_detail/283.htm' target='right' class='orange' >第二步是在得到用户将会评分的列表之后，预测用户会给该物品多少评分。</a><span class='green'>第一步则是本章要解决的内容， 该问题也可以说是Top-N推荐问题；</span><span class='green'>关于Top-N推荐的研究有很多。</span><a href='../sentence_detail/286.htm' target='right' class='orange' >其中协同过滤是很多生产系统中的主要算法[ ，  ]。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">154</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/287.htm' target='right' class='orange' >用户的行为数据根据是否是用户主动返回数据可将数据分为显性反馈数据， 隐形反馈数据；</a><span class='green'>显性反馈数据是用户通过评分体系等明显的方式主动返回的数据， 比如， 对物品的喜欢/不喜欢，评分， 评价等， 但是返回的数量比较少；</span><span class='green'>而对于隐形反馈数据，比如用户浏览商品的记录， 网站不可能在用户浏览物品之后让用户标记自己浏览过来物品， 而这种数据就是隐形数据。</span><span class='green'>这种数据不能明确用户是否喜欢物品， 但是用户关注物品了， 我们就可以通过这种关系为用户推荐与物品相关的推荐。</span><span class='green'>还有一种数据， 就是在一天中某一段时间的流量， 我们以分钟为单位来统计， 网站每分钟进入网站的流量，同时也可以观察流浪进来的渠道，是联通的多，还是电信的多， 是早上的流量高还是晚上的流量多；</span><a href='../sentence_detail/292.htm' target='right' class='orange' > 从这些数据我们可以进一步为用户提供更加优质的服务。</a><span class='green'>还有智能家居中面包机和咖啡机的开启时间，室内光线强弱的调整。</span><span class='green'>这些我们都可以通过用户反馈的隐形数据来给用户推荐执行。</span><a href='../sentence_detail/295.htm' target='right' class='orange' >期间用户根本不用明确的为推荐系统提供反馈数据。</a><span class='green'>这就是隐形反馈数据的优势， 当然文献[ ]中对这两种数据的优劣势做了详细的分析，虽然没有显性反馈数据那么明显的优势， 但是仔细思考它具有的某些特性也是显性数据所不具备的。</span><span class='green'>在特定的场景下， 隐形反馈数据也是能够反映用户的特性的。</span><a href='../sentence_detail/298.htm' target='right' class='orange' >本节主要描述利用隐形反馈数据来过滤和用户有关系的物品列表， 即Top-N推荐。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">155</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>问题数学定 义和概括</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">156</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>传统Top-N推荐</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">157</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>一般的数据集Data = {( user， item)}，其中数据集中的每个二元组( user， item)代表用户 user对物品 item产生过行为。</span><span class='green'>Top-N推荐的目的：</span><a href='../sentence_detail/303.htm' target='right' class='orange' > 为用户推荐用户最感兴趣的物品；</a><a href='../sentence_detail/304.htm' target='right' class='orange' >Top-N的方法就是为用户建立用户兴趣模型。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">158</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>基于时间的Top-N推荐</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">159</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/306.htm' target='right' class='orange' >用户的兴趣是随着时间变化的，并且用户的历史行为也随之增加。</a><a href='../sentence_detail/307.htm' target='right' class='orange' >这时用户的兴趣随着发生一定的偏移，长期兴趣不变， 但是短期兴趣很有可能随着时间的变化而转移。</a><span class='green'>为了适应用户兴趣的变化，推荐结果也随之发生变化，这变化最主要是要考虑时间因素， 本章要解决的问题是在给定时间内，为用户提供用户感兴趣的物品。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">160</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/309.htm' target='right' class='red' >推荐方法-基于图模型的协同过滤算法</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">161</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/310.htm' target='right' class='orange' >利用二分图为用户行为建模。</a><a href='../sentence_detail/311.htm' target='right' class='orange' >模型中U代表用户的集合， I代表物品的集合， 如果Ux对Iy产生了动作行为， 那么E代表两者之间的行为，而行为的强度定义为边的权重w(e)。</a><span class='green'>如图3-1所示， 图中定义了U1， U2， U3 和 I1， I2， I3， I4之间的关系。</span><a href='../sentence_detail/313.htm' target='right' class='orange' > 从图3-1中我们可以看到每对顶点代表一个用户和物品之间的关系；</a><span class='green'>比如 U1 和 I1， I4之间有行为；</span><span class='green'>U2对 I1， I3， I4有行为；</span><span class='green'>U3对I2， I3有行为。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">162</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图 3 1用户-物品关系图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">163</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/318.htm' target='right' class='orange' >Top-N推荐的主要任务就是找到和用户有行为的物品集；</a><span class='green'>反映到二分关系模型上就转化为了用户节点到物品节点是否存在路径， 有几条路径， 路径的度为多少；</span><span class='green'>比如，在图2中用户 U1到 I2，之间并没有直接关系，但是有 U1→ I4→ U3→ I2这条路径到达 I2，</span><span class='green'>也就是说 U1和 I2，之间有一条长短为3的关系。</span><span class='green'>计算图中顶点之间距离的算法有很多，Fouss在文[ ]中总结了很多， 我们介绍一种路径融合算法[ ]</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">164</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>路径融合算法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">165</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/324.htm' target='right' class='orange' >算法的基本思想是判断两个节点之间的相似度，其标准是：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">166</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在用户物品关系集合里有多条边可以连通两个节点；</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">167</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/326.htm' target='right' class='orange' >再者就是两顶点之间存在相对较短的路径；</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">168</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/327.htm' target='right' class='orange' >尽量避免在顶点之间路径中出现出度很大（热门物品）的节点。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">169</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>从以上三个标准中可以得到计算节点间相似度的过程，第一步我们先找到所有能够连通两个顶点之间的路径， 并计算每条路径的权重；</span><a href='../sentence_detail/329.htm' target='right' class='orange' >第二步比较权重和节点相连需要经过的边数找出最小的；</a><span class='green'>第三步若出现节点出度很大的节点，并且有其他路径选择，则舍弃出度大的那条路径。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">170</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>以图3-2为例。</span><a href='../sentence_detail/332.htm' target='right' class='orange' >为A用户推荐物品， 从图可知A对物品i1， i3产生过了行为，那么推荐物品只能在i2， i4之间产生；</a><span class='green'>然后我们从图观察看 A对 i2， A对 i3是否有路径，结果是 A到 i2有（ A，</span><span class='green'>i1， B， i4， D， i2）和（ A， i1， C，</span><span class='green'>i4， D， i2）两条路径；</span><span class='green'>而A到i4有（A，i1，B，i4）和（A，i1， C，i4）两条路径；</span><a href='../sentence_detail/337.htm' target='right' class='orange' >根据第一条标准我们找到了到两个节点的所有路径。</a><span class='green'>然后计算所有路径的边数。</span><a href='../sentence_detail/339.htm' target='right' class='orange' >A到i2，之间的两个路径的边数都是5条；</a><span class='green'>A到i4的两条路径的边数是3条。</span><a href='../sentence_detail/341.htm' target='right' class='orange' >根据第二条标准，用户对物品i4的兴趣相比物品i2的兴趣跟大一些；</a><span class='green'>然后在比较A到i4之间所经过的节点的出度的大小， B的出度为3，C的出度为2；</span><span class='green'>最有的路径即为（A，i1， C，i4）；</span><span class='green'>为了更加准确的计算用户对物品的相似度，我们可以规定当节点的出度不大于某值的时候，将所有的到节点i4的路径相加求平均，来精确用户对武平的相似度。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">171</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图 3 2 路径融合算法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">172</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>通过上面例子的详细描述，我们可以更加精确的描述路径融合算法了， 从而用数学公式来计算用户对物品的相似度也就是用户是否对物品感兴趣。</span><a href='../sentence_detail/347.htm' target='right' class='orange' >首先计算用户到物品的最短路径，之后再计算最短路径的权重；</a><a href='../sentence_detail/348.htm' target='right' class='orange' > 最后将所有最短路径的权重相加求出用户的物品的相似度。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">173</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>下面就是路径融合算法的数学表达：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">174</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>计算两点之间的路径权重，其中两点之间边的个数和经过的顶点的个数对权重的大小起着决定性的作用，数学定义：</span><span class='green'>设P为两点之间的路径， σ(V_n )?</span><span class='green'>[0，1]为顶点V的权重， ω(v，v')?</span><span class='green'>[0，1]为顶点v和v'之间边的权重；</span><span class='green'>那么P的权重定义为：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">175</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>γ(P)=σ(Vn)∏_(i=1)^(n-1)?</span><span class='green'>(σ(Vi)?</span><span class='green'>ω(V_i+V_(i+1)))/(|out(Vi)|ρ)             (3.1)</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">176</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中σ(V)?</span><span class='green'>[0，1]是顶点V的出度。</span><span class='green'>从公式是可得出当n越大， 也就是边的数量越多， 那么P的权重也就越小。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">177</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>我们在求两点之间的权重的时候是遍历求取图中点与点之间的权值，其实变相的也求得了用户和物品间的相似度了。</span><span class='green'>以下是数学定义：</span><a href='../sentence_detail/363.htm' target='right' class='orange' >p(V_1，V_n)为V1和Vn之间路径的集合，求V1 和 Vn 之间的相似度。</a><span class='green'>那么V1和Vn 的相似度为：</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_9.htm">尾页</a>
页码：4/9页
]
</div>

<br><br><br>
<div style="margin-left:25px">

<img src="../../images/guanwang.gif">
</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2015 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
